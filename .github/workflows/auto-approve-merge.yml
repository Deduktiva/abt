name: Auto Approve and Merge
permissions:
  contents: write
  pull-requests: write
  issues: write

on:
  issue_comment:
    types: [created]

jobs:
  auto-approve-merge:
    if: |
      github.event.issue.pull_request &&
      github.event.comment.body == '/approve' &&
      github.event.comment.author_association == 'MEMBER'
    runs-on: ubuntu-latest

    steps:
      - name: Get PR details
        id: pr
        uses: actions/github-script@v7
        with:
          script: |
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number
            });
            return {
              head_sha: pr.head.sha,
              mergeable: pr.mergeable,
              draft: pr.draft,
              state: pr.state
            };

      - name: Check if PR is ready
        if: fromJSON(steps.pr.outputs.result).draft == true
        run: |
          echo "PR is still a draft, skipping auto-merge"
          exit 1

      - name: Check if PR is closed
        if: fromJSON(steps.pr.outputs.result).state == 'closed'
        run: |
          echo "PR is closed, aborting auto-merge"
          exit 1

      - name: Wait for CI to complete
        uses: actions/github-script@v7
        with:
          script: |
            const head_sha = '${{ fromJSON(steps.pr.outputs.result).head_sha }}';

            // Wait up to 30 minutes for CI to complete
            const maxWaitTime = 30 * 60 * 1000; // 30 minutes
            const startTime = Date.now();

            while (Date.now() - startTime < maxWaitTime) {
              const { data: checks } = await github.rest.checks.listForRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: head_sha
              });

              const { data: statuses } = await github.rest.repos.listCommitStatusesForRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: head_sha
              });

              // Check if all checks are completed
              const allChecks = [...checks.check_runs, ...statuses];
              const pendingChecks = allChecks.filter(check =>
                (check.status === 'queued' || check.status === 'in_progress') ||
                (check.state === 'pending')
              );

              if (pendingChecks.length === 0) {
                // All checks completed, check if any failed
                const failedChecks = allChecks.filter(check =>
                  check.conclusion === 'failure' || check.state === 'failure' ||
                  check.conclusion === 'cancelled' || check.state === 'error'
                );

                if (failedChecks.length > 0) {
                  console.log('Some checks failed:', failedChecks.map(c => c.name || c.context));
                  await github.rest.issues.createComment({
                    issue_number: context.issue.number,
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    body: '❌ Cannot auto-merge: CI checks failed'
                  });
                  process.exit(1);
                } else {
                  console.log('All checks passed!');
                  break;
                }
              }

              console.log(`Waiting for ${pendingChecks.length} checks to complete...`);
              await new Promise(resolve => setTimeout(resolve, 30000)); // Wait 30 seconds
            }

            if (Date.now() - startTime >= maxWaitTime) {
              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: '⏰ Timeout waiting for CI to complete'
              });
              process.exit(1);
            }

      - name: Approve PR
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.pulls.createReview({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number,
              event: 'APPROVE',
              body: '✅ Auto-approved via /approve command'
            });

      - name: Auto-merge PR
        uses: actions/github-script@v7
        with:
          script: |
            try {
              await github.rest.pulls.merge({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: context.issue.number,
                merge_method: 'merge'
              });
            } catch (error) {
              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: `❌ Failed to auto-merge: ${error.message}`
              });
              throw error;
            }

      - name: Delete source branch
        uses: actions/github-script@v7
        with:
          script: |
            try {
              // Get PR details to get the source branch name
              const { data: pr } = await github.rest.pulls.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: context.issue.number
              });

              const sourceBranchName = pr.head.ref;
              const sourceRepo = pr.head.repo.full_name;
              const targetRepo = context.repo.owner + '/' + context.repo.repo;

              // Only delete if the source branch is from the same repository (not a fork)
              if (sourceRepo !== targetRepo) {
                console.log(`Skipping branch deletion: source branch is from fork ${sourceRepo}`);
                return;
              }

              // Check if the branch is protected
              try {
                const { data: branch } = await github.rest.repos.getBranch({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  branch: sourceBranchName
                });

                if (branch.protected) {
                  console.log(`Skipping deletion of protected branch: ${sourceBranchName}`);
                  return;
                }
              } catch (error) {
                // Branch might not exist anymore, which is fine
                if (error.status === 404) {
                  console.log(`Branch ${sourceBranchName} not found, may have been already deleted`);
                  return;
                }
                // For other errors, log but don't fail the workflow
                console.log(`Aborting: Could not check branch protection status: ${error.message}`);
                return;
              }

              // Delete the source branch
              await github.rest.git.deleteRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: `heads/${sourceBranchName}`
              });

              console.log(`Successfully deleted source branch: ${sourceBranchName}`);
            } catch (error) {
              // Log the error but don't fail the workflow - branch deletion is not critical
              console.log(`Warning: Failed to delete source branch: ${error.message}`);
            }
